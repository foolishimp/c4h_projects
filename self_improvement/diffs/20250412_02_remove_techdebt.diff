===CHANGE_BEGIN===
FILE: /Users/jim/src/apps/c4h_editor/backend/services/c4h_service.py
TYPE: modify
DESCRIPTION: Remove legacy/redundant submit_job and submit_job_tuple methods.
DIFF:
--- a/Users/jim/src/apps/c4h_editor/backend/services/c4h_service.py
+++ b/Users/jim/src/apps/c4h_editor/backend/services/c4h_service.py
@@ -101,108 +101,6 @@
             return JobSubmissionResponse(job_id="", status="error", message=f"Error submitting job: {str(e)}")
 
     async def submit_job(self, workorder: Configuration = None, team: Configuration = None, runtime: Configuration = None) -> JobSubmissionResponse:
-        """Legacy method for backward compatibility - will be deprecated in future releases."""
-        """
-        Submit a job with multiple configurations to the C4H service.
-        Payload structure is aligned with the C4H Service API's JobRequest model,
-        accounting for the nested structure within the .content field (content.<config_type>.<data>).
-        """
-        # Validate inputs
-        if not workorder:
-            raise ValueError("Workorder configuration is required for job submission")
-
-        logger.info(f"Preparing job submission for workorder={workorder.id}"
-                    f"{f', team={team.id}' if team else ''}"
-                    f"{f', runtime={runtime.id}' if runtime else ''}")
-
-        # --- Construct payload matching C4H Service JobRequest model ---
-        payload = {}
-
-        # 1. Workorder section (Required by JobRequest)
-        # Extracts from workorder.content.workorder.<field>
-        if isinstance(workorder.content, dict):
-            # Get the nested 'workorder' dictionary first
-            workorder_data = workorder.content.get("workorder", {})
-
-            if isinstance(workorder_data, dict):
-                payload["workorder"] = {
-                    "project": workorder_data.get("project", {}),
-                    "intent": workorder_data.get("intent", {})
-                }
-
-                # Check required fields within the nested structure
-                if not payload["workorder"]["project"].get("path"):
-                    logger.warning(f"Workorder {workorder.id} content missing 'workorder.project.path'")
-                if not payload["workorder"]["intent"].get("description"):
-                    logger.warning(f"Workorder {workorder.id} content missing 'workorder.intent.description'")
-
-            else:
-                logger.error(f"Workorder {workorder.id} 'content.workorder' is not a dictionary.")
-                # Set empty to trigger validation error downstream if needed, or raise here
-                payload["workorder"] = {"project": {}, "intent": {}}
-                # Or raise ValueError("Invalid content.workorder structure")
-
-        else:
-            logger.error(f"Workorder {workorder.id} content is not a dictionary.")
-            raise ValueError(f"Invalid content format for workorder {workorder.id}")
-
-        # 2. Team section (Optional by JobRequest)
-        # Extracts from team.content.team.<field>
-        if team:
-            if isinstance(team.content, dict):
-
-                # Get the nested 'team' dictionary first
-                team_data = team.content.get("team", {})
-                if isinstance(team_data, dict):
-                    # Extract only the keys expected by the TeamConfig model
-                    team_payload_section = {
-                        "llm_config": team_data.get("llm_config"),
-                        "orchestration": team_data.get("orchestration")
-                    }
-                    # Remove keys with None values
-
-                    team_payload_section = {k: v for k, v in team_payload_section.items() if v is not None}
-                    if team_payload_section: # Only add if not empty
-                        payload["team"] = team_payload_section
-                else:
-
-                    logger.warning(f"Team config {team.id} 'content.team' is not a dictionary, skipping team payload section.")
-            else:
-                logger.warning(f"Team config {team.id} content is not a dictionary, skipping team payload section.")
-
-        # 3. Runtime section (Optional by JobRequest)
-        # Assumes runtime.content.runtime.<field> structure
-
-        if runtime:
-            if isinstance(runtime.content, dict):
-                # Get the nested 'runtime' dictionary first
-                runtime_data = runtime.content.get("runtime", {})
-                if isinstance(runtime_data, dict):
-                    # Extract only the keys expected by the RuntimeConfig model
-                    # Note the nested 'runtime' key expected by the server model *within* this section
-                    runtime_payload_section = {
-                        "runtime": runtime_data.get("runtime"), # Corresponds to RuntimeConfig.runtime
-
-                        "logging": runtime_data.get("logging"),
-                        "backup": runtime_data.get("backup")
-                    }
-                    # Remove keys with None values
-
-                    runtime_payload_section = {k: v for k, v in runtime_payload_section.items() if v is not None}
-                    if runtime_payload_section: # Only add if not empty
-                        payload["runtime"] = runtime_payload_section
-                else:
-
-                    logger.warning(f"Runtime config {runtime.id} 'content.runtime' is not a dictionary, skipping runtime payload section.")
-            else:
-                logger.warning(f"Runtime config {runtime.id} content is not a dictionary, skipping runtime payload section.")
-
-        # --- End of Payload Construction ---
-
-        # Prepare request URL
-        url_parts = [self.api_base]
-        if self.api_version:
-
-            url_parts.append(self.api_version)
-        url_parts.append("jobs")
-        url = "/".join(s.strip('/') for s in url_parts)
-
-        # Prepare headers
-        headers = {"Content-Type": "application/json"}
-        if self.api_key:
-            headers["Authorization"] = f"Bearer {self.api_key}"
-
-        logger.info(f"Submitting job data to URL: {url}")
-        try:
-
-            # Log the exact payload being sent
-            payload_json = json.dumps(payload, indent=2)
-            # Use INFO level for visibility during debugging
-            logger.debug(f"Attempting POST request to URL: {url} with payload:\n{payload_json}") # Original DEBUG log
-        except Exception as json_err:
-            logger.error(f"Failed to serialize payload for logging: {json_err}")
-
-            logger.info(f"Attempting POST request to URL: {url} with payload (raw): {payload}") # Log raw dict as fallback
-
-        # Send request
-        try:
-            response = await self.http_client.post(url, headers=headers, json=payload)
-
-            # Handle errors (including 422 Validation Errors)
-            if response.status_code >= 400:
-
-                logger.error(f"C4H API error: status_code={response.status_code}, response={response.text}")
-                error_msg = f"C4H API error: {response.status_code}"
-                try:
-                    error_data = response.json()
-                    detail = error_data.get("detail")
-
-                    if isinstance(detail, list) and detail: # FastAPI validation error format
-                        try:
-                            formatted_errors = "; ".join([f"{e.get('loc', ['unknown'])[-1]}: {e.get('msg', 'validation error')}" for e in detail])
-                            error_msg = f"Validation Error ({response.status_code}): {formatted_errors}"
-                        except Exception:
-                            error_msg = f"Validation Error ({response.status_code}): {json.dumps(detail)}"
-
-                    elif isinstance(detail, str):
-                        error_msg += f": {detail}"
-                    elif "message" in error_data: error_msg = error_data["message"]
-                    elif "error" in error_data: error_msg = error_data["error"]
-                except Exception:
-                    error_msg = response.text
-                return JobSubmissionResponse(job_id="", status="error", message=error_msg)
-
-            # Parse successful response
-            response_data = response.json()
-            return JobSubmissionResponse(
-                job_id=response_data.get("job_id", ""),
-                status=response_data.get("status", "unknown"),
-                message=response_data.get("message"),
-                storage_path=response_data.get("storage_path")
-            )
-        except httpx.ConnectError as e:
-
-            logger.error(f"Connection Error during POST to {url}: {str(e)}", exc_info=True)
-            return JobSubmissionResponse(
-                job_id="", status="error", message=f"Connection Error: {str(e)}"
-            )
-        except Exception as e:
-            logger.error(f"HTTP client error during POST to {url}: {str(e)}", exc_info=True)
-            return JobSubmissionResponse(
-
-                job_id="", status="error", message=f"Error submitting job: {str(e)}"
-            )
-
-
     # --- get_job_status and cancel_job remain as modified previously ---
     # (They don't need payload alignment, only URL logging and mock removal)
 

===CHANGE_END===